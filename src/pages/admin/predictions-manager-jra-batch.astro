---
/**
 * JRAäºˆæƒ³ãƒ‡ãƒ¼ã‚¿ç®¡ç†ç”»é¢ï¼ˆ12ãƒ¬ãƒ¼ã‚¹ä¸€æ‹¬å…¥åŠ›ç‰ˆï¼‰
 * predictions-manager-jraã¨ã¯å®Œå…¨ã«åˆ¥ã®ãƒ•ã‚¡ã‚¤ãƒ«
 *
 * æ©Ÿèƒ½:
 * - 12ãƒ¬ãƒ¼ã‚¹åˆ†ã®HTMLã‚’ä¸€æ‹¬è²¼ã‚Šä»˜ã‘
 * - ãƒ¬ãƒ¼ã‚¹å¢ƒç•Œã‚’è‡ªå‹•æ¤œå‡ºã—ã¦åˆ†å‰²
 * - å„ãƒ¬ãƒ¼ã‚¹ã‚’å€‹åˆ¥ã«æŠ½å‡ºãƒ»ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
 * - 12ãƒ¬ãƒ¼ã‚¹åˆ†ã‚’1ã¤ã®JSONãƒ•ã‚¡ã‚¤ãƒ«ã«ä¿å­˜
 *
 * è‘—ä½œæ¨©å¯¾å¿œ: è¨˜è€…åã‚’å°ç•ªå·åŒ–ï¼ˆå°5/å°4/å°3/å°2/å°1ï¼‰
 */
import BaseLayout from "../../layouts/BaseLayout.astro";

export const prerender = false;
---

<BaseLayout
  title="JRA äºˆæƒ³ç®¡ç†ç”»é¢ï¼ˆä¸€æ‹¬å…¥åŠ›ï¼‰"
  description="ä¸­å¤®ç«¶é¦¬ï¼ˆJRAï¼‰12ãƒ¬ãƒ¼ã‚¹åˆ†ã®äºˆæƒ³HTMLã‚’ä¸€æ‹¬ã§è§£æã—ã¦ãƒ‡ãƒ¼ã‚¿åŒ–ã—ã¾ã™"
>
  <section class="admin-section">
    <div class="container">
      <h1 class="page-title">âš¡ ä¸­å¤®ç«¶é¦¬ï¼ˆJRAï¼‰ äºˆæƒ³ç®¡ç†ï¼ˆ12ãƒ¬ãƒ¼ã‚¹ä¸€æ‹¬ï¼‰</h1>
      <p class="page-description">
        <strong>12ãƒ¬ãƒ¼ã‚¹åˆ†ã®HTMLã‚’ä¸€åº¦ã«è²¼ã‚Šä»˜ã‘ã¦ä¸€æ‹¬å‡¦ç†ã§ãã¾ã™</strong><br>
        â€» å€‹åˆ¥å…¥åŠ›ãŒå¿…è¦ãªå ´åˆã¯ <a href="/admin/predictions-manager-jra" style="color: var(--primary-end); text-decoration: underline;">JRA äºˆæƒ³ç®¡ç†ï¼ˆå€‹åˆ¥å…¥åŠ›ï¼‰</a> ã‚’ã”åˆ©ç”¨ãã ã•ã„
      </p>

      <!-- å…±é€šæƒ…å ±å…¥åŠ› -->
      <div class="card common-info-card">
        <h2>ğŸ“… é–‹å‚¬æƒ…å ±ï¼ˆå…¨ãƒ¬ãƒ¼ã‚¹å…±é€šï¼‰</h2>
        <div class="common-info-grid">
          <div class="form-group">
            <label for="commonDate">é–‹å‚¬æ—¥</label>
            <input
              type="date"
              id="commonDate"
              class="form-input"
              value={new Date().toISOString().split('T')[0]}
            />
            <p style="font-size: 0.875rem; color: var(--text-secondary); margin-top: 0.25rem;">
              è‡ªå‹•åˆ¤åˆ¥ã•ã‚Œã¾ã™ï¼ˆæ‰‹å‹•å¤‰æ›´ã‚‚å¯ï¼‰
            </p>
          </div>
          <div class="form-group">
            <label for="commonVenue">ç«¶é¦¬å ´</label>
            <select id="commonVenue" class="form-select">
              <option value="" selected>è‡ªå‹•</option>
              <option value="æ±äº¬">æ±äº¬</option>
              <option value="ä¸­å±±">ä¸­å±±</option>
              <option value="äº¬éƒ½">äº¬éƒ½</option>
              <option value="é˜ªç¥">é˜ªç¥</option>
              <option value="ä¸­äº¬">ä¸­äº¬</option>
              <option value="æ–°æ½Ÿ">æ–°æ½Ÿ</option>
              <option value="ç¦å³¶">ç¦å³¶</option>
              <option value="å°å€‰">å°å€‰</option>
              <option value="æœ­å¹Œ">æœ­å¹Œ</option>
              <option value="å‡½é¤¨">å‡½é¤¨</option>
            </select>
            <p style="font-size: 0.875rem; color: var(--text-secondary); margin-top: 0.25rem;">
              è‡ªå‹•åˆ¤åˆ¥ã•ã‚Œã¾ã™ï¼ˆæ‰‹å‹•å¤‰æ›´ã‚‚å¯ï¼‰
            </p>
          </div>
        </div>
      </div>

      <!-- ä¸€æ‹¬å…¥åŠ›ã‚¨ãƒªã‚¢ -->
      <div class="card input-card">
        <h2>ğŸ“‹ 12ãƒ¬ãƒ¼ã‚¹åˆ†ã®äºˆæƒ³HTMLè²¼ã‚Šä»˜ã‘</h2>
        <p style="color: var(--text-secondary); margin-bottom: var(--spacing-md);">
          äºˆæƒ³ã‚µã‚¤ãƒˆã‹ã‚‰<strong>ç¬¬1Rã€œç¬¬12R</strong>ã¾ã§ã®HTMLã‚’å…¨ã¦ã‚³ãƒ”ãƒ¼ã—ã¦ã€ä¸‹ã®ãƒ†ã‚­ã‚¹ãƒˆã‚¨ãƒªã‚¢ã«è²¼ã‚Šä»˜ã‘ã¦ãã ã•ã„ã€‚<br>
          è‡ªå‹•çš„ã«ãƒ¬ãƒ¼ã‚¹ã”ã¨ã«åˆ†å‰²ãƒ»è§£æã—ã¾ã™ã€‚
        </p>

        <textarea
          id="batchInput"
          class="batch-textarea"
          rows="20"
          placeholder="12ãƒ¬ãƒ¼ã‚¹åˆ†ã®HTMLã‚’è²¼ã‚Šä»˜ã‘ã¦ãã ã•ã„

ä¾‹:
<div class='racename'>
  <div class='racenameleft'>
    <p>2026å¹´2æœˆ8æ—¥</p>
    <h2>1å›å°å€‰6æ—¥ç›®</h2>
    <h1>å°å€‰æ—¥çµŒè³</h1>
  </div>
  ...
</div>
<table class='default syutuba'>...</table>

<div class='racename'>
  <div class='racenameleft'>
    <p>2026å¹´2æœˆ8æ—¥</p>
    <h2>1å›å°å€‰6æ—¥ç›®</h2>
    <h1>ç¬¬2ãƒ¬ãƒ¼ã‚¹</h1>
  </div>
  ...
</div>
<table class='default syutuba'>...</table>

... (ç¬¬12Rã¾ã§)"
        ></textarea>

        <div class="action-buttons" style="margin-top: var(--spacing-lg);">
          <button
            type="button"
            class="btn btn-primary btn-large"
            onclick="parseBatchRaces()"
          >
            ğŸ” 12ãƒ¬ãƒ¼ã‚¹ä¸€æ‹¬è§£æ
          </button>
        </div>

        <div id="parseStatus" class="parse-status" style="display: none;"></div>
      </div>

      <!-- ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚¨ãƒªã‚¢ -->
      <div id="previewSection" class="preview-section" style="display: none;">
        <div class="card">
          <h2>âœ… è§£æçµæœãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼</h2>
          <div id="raceSummary" class="race-summary"></div>

          <!-- å„ãƒ¬ãƒ¼ã‚¹ã®è©³ç´°ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ -->
          <div id="raceDetails" class="race-details"></div>

          <!-- ä¸€æ‹¬ä¿å­˜ãƒœã‚¿ãƒ³ -->
          <div class="action-buttons" style="margin-top: var(--spacing-2xl);">
            <button
              type="button"
              class="btn btn-secondary"
              onclick="copyAllJSON()"
            >
              ğŸ“‹ JSONå…¨ã‚³ãƒ”ãƒ¼
            </button>
            <button
              type="button"
              id="saveAllBtn"
              class="btn btn-success btn-large"
              onclick="saveAllRacesToGit(false)"
            >
              ğŸš€ 12ãƒ¬ãƒ¼ã‚¹ä¸€æ‹¬ä¿å­˜ã—ã¦Git Push
            </button>
            <button
              type="button"
              class="btn btn-warning"
              onclick="if(confirm('ã“ã®æ—¥ä»˜ã®æ—¢å­˜ãƒ‡ãƒ¼ã‚¿ã‚’å®Œå…¨ã«ä¸Šæ›¸ãã—ã¾ã™ã€‚ã‚ˆã‚ã—ã„ã§ã™ã‹ï¼Ÿ')) saveAllRacesToGit(true)"
            >
              ğŸ”¥ å®Œå…¨ä¸Šæ›¸ãä¿å­˜
            </button>
          </div>
          <div id="saveStatus" class="save-status" style="display: none;"></div>
        </div>
      </div>

      <!-- ä½¿ç”¨æ–¹æ³• -->
      <div class="card info-card">
        <h2>ğŸ“– ä½¿ç”¨æ–¹æ³•</h2>
        <ol>
          <li>äºˆæƒ³ã‚µã‚¤ãƒˆã‹ã‚‰<strong>ç¬¬1Rã€œç¬¬12Rå…¨ã¦ã®HTML</strong>ã‚’ã‚³ãƒ”ãƒ¼</li>
          <li>ä¸Šã®ãƒ†ã‚­ã‚¹ãƒˆã‚¨ãƒªã‚¢ã«è²¼ã‚Šä»˜ã‘</li>
          <li>ã€Œ12ãƒ¬ãƒ¼ã‚¹ä¸€æ‹¬è§£æã€ãƒœã‚¿ãƒ³ã‚’ã‚¯ãƒªãƒƒã‚¯</li>
          <li><strong>é–‹å‚¬æ—¥ãƒ»ç«¶é¦¬å ´ãŒè‡ªå‹•åˆ¤åˆ¥ã•ã‚Œã¾ã™</strong>ï¼ˆå¿…è¦ãªã‚‰æ‰‹å‹•å¤‰æ›´ã‚‚å¯èƒ½ï¼‰</li>
          <li>ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã§å„ãƒ¬ãƒ¼ã‚¹ã®æŠ½å‡ºçµæœã‚’ç¢ºèª</li>
          <li>ã€Œ12ãƒ¬ãƒ¼ã‚¹ä¸€æ‹¬ä¿å­˜ã—ã¦Git Pushã€ã§ keiba-data-shared ã«ä¿å­˜</li>
          <li>è‡ªå‹•çš„ã«å„äºˆæƒ³ã‚µã‚¤ãƒˆã«åæ˜ ã•ã‚Œã¾ã™ ğŸ‰</li>
        </ol>

        <h3>ğŸ’¡ ãƒã‚¤ãƒ³ãƒˆ</h3>
        <ul>
          <li>12ãƒ¬ãƒ¼ã‚¹åˆ†ã‚’ä¸€åº¦ã«å‡¦ç†ã§ãã¾ã™ï¼ˆåŠ¹ç‡é‡è¦–ï¼‰</li>
          <li><strong>é–‹å‚¬æ—¥ãƒ»ç«¶é¦¬å ´ã¯è‡ªå‹•åˆ¤åˆ¥ã•ã‚Œã¾ã™</strong>ï¼ˆHTMLã‹ã‚‰æŠ½å‡ºï¼‰</li>
          <li>è‡ªå‹•åˆ¤åˆ¥ã•ã‚ŒãŸå€¤ã¯ä¸Šéƒ¨ã®ãƒ•ã‚©ãƒ¼ãƒ ã«åæ˜ ã•ã‚Œã¾ã™ï¼ˆæ‰‹å‹•å¤‰æ›´ã‚‚å¯èƒ½ï¼‰</li>
          <li>ã‚¨ãƒ©ãƒ¼ãŒå‡ºãŸãƒ¬ãƒ¼ã‚¹ã¯èµ¤è‰²ã§è¡¨ç¤ºã•ã‚Œã¾ã™</li>
          <li>æ…é‡ã«ç¢ºèªã—ãŸã„å ´åˆã¯ <a href="/admin/predictions-manager-jra" style="color: var(--primary-end);">å€‹åˆ¥å…¥åŠ›</a> ã‚’ã”åˆ©ç”¨ãã ã•ã„</li>
          <li>æ—¢å­˜ãƒ‡ãƒ¼ã‚¿ã¯è‡ªå‹•çš„ã«ãƒãƒ¼ã‚¸ã•ã‚Œã¾ã™ï¼ˆä¸Šæ›¸ãã•ã‚Œã¾ã›ã‚“ï¼‰</li>
        </ul>
      </div>
    </div>
  </section>

  <style>
    .admin-section {
      padding: var(--spacing-2xl) 0;
      min-height: 100vh;
    }

    .page-title {
      font-size: 2rem;
      margin-bottom: var(--spacing-md);
      text-align: center;
    }

    .page-description {
      text-align: center;
      color: var(--text-secondary);
      margin-bottom: var(--spacing-2xl);
      line-height: 1.6;
    }

    .common-info-card {
      max-width: 800px;
      margin: 0 auto var(--spacing-2xl);
    }

    .common-info-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: var(--spacing-lg);
      margin-top: var(--spacing-md);
    }

    .form-group {
      display: flex;
      flex-direction: column;
      gap: var(--spacing-sm);
    }

    .form-group label {
      font-weight: 600;
      color: var(--text-primary);
    }

    .form-input,
    .form-select {
      padding: var(--spacing-sm) var(--spacing-md);
      border: 1px solid var(--border-color);
      border-radius: var(--radius-md);
      background: var(--bg-secondary);
      color: var(--text-primary);
      font-size: 1rem;
    }

    .input-card {
      max-width: 1200px;
      margin: 0 auto var(--spacing-2xl);
    }

    .batch-textarea {
      width: 100%;
      padding: var(--spacing-md);
      border: 1px solid var(--border-color);
      border-radius: var(--radius-md);
      background: var(--bg-secondary);
      color: var(--text-primary);
      font-family: 'Courier New', monospace;
      font-size: 0.875rem;
      resize: vertical;
      min-height: 400px;
    }

    .action-buttons {
      display: flex;
      gap: var(--spacing-md);
      flex-wrap: wrap;
    }

    .btn-large {
      flex: 1;
      min-width: 200px;
    }

    .parse-status,
    .save-status {
      margin-top: var(--spacing-md);
      padding: var(--spacing-md);
      border-radius: var(--radius-md);
      font-weight: 600;
      display: none;
    }

    .parse-status.success,
    .save-status.success {
      background: rgba(16, 185, 129, 0.1);
      border-left: 4px solid var(--success);
      color: var(--success);
    }

    .parse-status.error,
    .save-status.error {
      background: rgba(239, 68, 68, 0.1);
      border-left: 4px solid var(--error);
      color: var(--error);
    }

    .parse-status.loading,
    .save-status.loading {
      background: rgba(59, 130, 246, 0.1);
      border-left: 4px solid var(--primary-end);
      color: var(--primary-end);
    }

    .preview-section {
      max-width: 1200px;
      margin: 0 auto var(--spacing-2xl);
    }

    .race-summary {
      margin-bottom: var(--spacing-xl);
      padding: var(--spacing-lg);
      background: var(--bg-secondary);
      border-radius: var(--radius-md);
    }

    .race-details {
      display: flex;
      flex-direction: column;
      gap: var(--spacing-md);
    }

    .race-detail-card {
      border: 2px solid var(--border-color);
      border-radius: var(--radius-md);
      overflow: hidden;
    }

    .race-detail-card.success {
      border-color: var(--success);
    }

    .race-detail-card.error {
      border-color: var(--error);
    }

    .race-detail-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: var(--spacing-lg);
      cursor: pointer;
      font-weight: 600;
      font-size: 1.25rem;
      user-select: none;
      background: var(--bg-secondary);
    }

    .race-detail-header:hover {
      background: var(--bg-tertiary);
    }

    .race-number-badge {
      color: var(--primary-end);
      font-size: 1.5rem;
    }

    .race-status-badge {
      font-size: 0.875rem;
      padding: 4px 12px;
      border-radius: var(--radius-sm);
      font-weight: 600;
    }

    .race-status-badge.success {
      background: rgba(16, 185, 129, 0.2);
      color: var(--success);
    }

    .race-status-badge.error {
      background: rgba(239, 68, 68, 0.2);
      color: var(--error);
    }

    .race-detail-content {
      padding: var(--spacing-lg);
      border-top: 1px solid var(--border-color);
    }

    .info-card {
      max-width: 1200px;
      margin: var(--spacing-2xl) auto 0;
    }

    .info-card ol,
    .info-card ul {
      margin-left: var(--spacing-lg);
      color: var(--text-secondary);
    }

    .info-card li {
      margin-bottom: var(--spacing-sm);
    }

    @media (max-width: 768px) {
      .common-info-grid {
        grid-template-columns: 1fr;
      }

      .action-buttons {
        flex-direction: column;
      }

      .btn-large {
        width: 100%;
      }
    }
  </style>

  <script is:inline>
    // ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°
    let batchResults = [];

    // ä¸€æ‹¬è§£æãƒ¡ã‚¤ãƒ³é–¢æ•°
    function parseBatchRaces() {
      const textarea = document.getElementById('batchInput');
      const html = textarea.value;

      if (!html.trim()) {
        alert('12ãƒ¬ãƒ¼ã‚¹åˆ†ã®HTMLã‚’å…¥åŠ›ã—ã¦ãã ã•ã„');
        return;
      }

      const statusDiv = document.getElementById('parseStatus');
      statusDiv.style.display = 'block';
      statusDiv.className = 'parse-status loading';
      statusDiv.textContent = 'ğŸ” 12ãƒ¬ãƒ¼ã‚¹åˆ†ã‚’è§£æä¸­...';

      try {
        // ãƒ¬ãƒ¼ã‚¹å¢ƒç•Œã§åˆ†å‰²
        const raceHTMLs = splitRacesHTML(html);
        console.log(`[parseBatchRaces] æ¤œå‡ºã—ãŸãƒ¬ãƒ¼ã‚¹æ•°: ${raceHTMLs.length}`);

        if (raceHTMLs.length === 0) {
          statusDiv.className = 'parse-status error';
          statusDiv.textContent = 'âŒ ãƒ¬ãƒ¼ã‚¹ãŒæ¤œå‡ºã§ãã¾ã›ã‚“ã§ã—ãŸã€‚HTMLã®å½¢å¼ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚';
          return;
        }

        // å…±é€šæƒ…å ±å–å¾—
        let date = document.getElementById('commonDate').value;
        let commonVenue = document.getElementById('commonVenue').value;

        // å„ãƒ¬ãƒ¼ã‚¹ã‚’è§£æ
        batchResults = [];
        let successCount = 0;
        let errorCount = 0;

        raceHTMLs.forEach((raceHTML, index) => {
          const raceNum = index + 1;
          try {
            const extracted = extractPredictions(raceHTML);
            if (!extracted.success) {
              batchResults.push({
                raceNumber: raceNum,
                success: false,
                errors: extracted.errors,
              });
              errorCount++;
              return;
            }

            const raceInfo = extractRaceInfo(raceHTML);
            const scored = scoreAndAssign(extracted);

            // ç«¶é¦¬å ´ï¼šè‡ªå‹•æŠ½å‡ºã‚’å„ªå…ˆã€ãªã‘ã‚Œã°æ‰‹å‹•é¸æŠã‚’ä½¿ç”¨
            let venue = raceInfo.venue || commonVenue;

            // é–‹å‚¬æ—¥ï¼šè‡ªå‹•æŠ½å‡ºã‚’å„ªå…ˆã€ãªã‘ã‚Œã°æ‰‹å‹•å…¥åŠ›ã‚’ä½¿ç”¨
            let raceDate = date; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯æ‰‹å‹•å…¥åŠ›å€¤
            if (raceInfo.date) {
              // "2026å¹´2æœˆ8æ—¥" â†’ "2026-02-08" ã«å¤‰æ›
              const dateMatch = raceInfo.date.match(/(\d{4})å¹´(\d{1,2})æœˆ(\d{1,2})æ—¥/);
              if (dateMatch) {
                const yyyy = dateMatch[1];
                const mm = String(dateMatch[2]).padStart(2, '0');
                const dd = String(dateMatch[3]).padStart(2, '0');
                raceDate = `${yyyy}-${mm}-${dd}`;
              }
            }

            // æœ€åˆã®ãƒ¬ãƒ¼ã‚¹ã§è‡ªå‹•æŠ½å‡ºã—ãŸæƒ…å ±ã‚’ãƒ•ã‚©ãƒ¼ãƒ ã«åæ˜ ï¼ˆãƒ¦ãƒ¼ã‚¶ãƒ¼ç¢ºèªç”¨ï¼‰
            if (raceNum === 1) {
              if (raceInfo.venue) {
                document.getElementById('commonVenue').value = raceInfo.venue;
                commonVenue = raceInfo.venue; // ä»¥é™ã®ãƒ¬ãƒ¼ã‚¹ã§ã‚‚ä½¿ç”¨
                console.log(`[parseBatchRaces] ğŸ¯ ç«¶é¦¬å ´ã‚’è‡ªå‹•æŠ½å‡º: ${raceInfo.venue}`);
              }
              if (raceDate !== date) {
                document.getElementById('commonDate').value = raceDate;
                date = raceDate; // ä»¥é™ã®ãƒ¬ãƒ¼ã‚¹ã§ã‚‚ä½¿ç”¨
                console.log(`[parseBatchRaces] ğŸ“… é–‹å‚¬æ—¥ã‚’è‡ªå‹•æŠ½å‡º: ${raceDate}`);
              }
            }

            const data = {
              version: "1.0.0",
              createdAt: new Date().toISOString(),
              lastUpdated: new Date().toISOString(),
              raceInfo: {
                date: raceDate, // è‡ªå‹•åˆ¤åˆ¥ã—ãŸæ—¥ä»˜ã‚’ä½¿ç”¨
                track: venue,
                raceNumber: raceInfo.raceNo || `${raceNum}R`,
                raceName: raceInfo.raceName,
                raceType: raceInfo.raceType,
                distance: raceInfo.distance,
                surface: raceInfo.surface,
                kaisaiInfo: raceInfo.kaisaiInfo,
                hassoTime: raceInfo.hassoTime,
                courseInfo: raceInfo.courseInfo,
                tenkiBaba: raceInfo.tenkiBaba,
                recordTime: raceInfo.recordTime,
                estimatedTime: raceInfo.estimatedTime,
                prizes: raceInfo.prizes,
              },
              horses: scored.horses.map(h => ({
                number: h.number,
                name: h.name,
                umacd: h.umacd,
                marks: h.marks,
                seirei: h.seirei,
                kisyu: h.kisyu,
                kinryo: h.kinryo,
                kyusya: h.kyusya,
                totalScore: h.totalScore,
                assignment: h.assignment,
              })),
              predictors: scored.predictors,
              assignments: {
                main: scored.assignments.main?.number,
                sub: scored.assignments.sub?.number,
                hole: scored.assignments.hole?.number,
                connectTop: scored.assignments.connectTop?.number,
                connect: scored.assignments.connect.map(h => h.number),
                reserve: scored.assignments.reserve.map(h => h.number),
                none: scored.assignments.none.map(h => h.number),
              },
            };

            batchResults.push({
              raceNumber: raceNum,
              success: true,
              data,
              date: raceDate, // è‡ªå‹•åˆ¤åˆ¥ã—ãŸæ—¥ä»˜ã‚’ä½¿ç”¨
              venue,
            });
            successCount++;

          } catch (error) {
            console.error(`ç¬¬${raceNum}Rè§£æã‚¨ãƒ©ãƒ¼:`, error);
            batchResults.push({
              raceNumber: raceNum,
              success: false,
              errors: [error.message],
            });
            errorCount++;
          }
        });

        // ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ›´æ–°
        statusDiv.className = errorCount > 0 ? 'parse-status error' : 'parse-status success';
        statusDiv.innerHTML = `
          âœ… è§£æå®Œäº†: æˆåŠŸ ${successCount}ãƒ¬ãƒ¼ã‚¹ / ã‚¨ãƒ©ãƒ¼ ${errorCount}ãƒ¬ãƒ¼ã‚¹<br>
          ${errorCount > 0 ? 'âš ï¸ ã‚¨ãƒ©ãƒ¼ãŒå‡ºãŸãƒ¬ãƒ¼ã‚¹ã¯ä¸‹ã§ç¢ºèªã—ã¦ãã ã•ã„' : ''}
        `;

        // ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼è¡¨ç¤º
        displayBatchPreview(batchResults, date, commonVenue);

      } catch (error) {
        statusDiv.className = 'parse-status error';
        statusDiv.innerHTML = `âŒ ã‚¨ãƒ©ãƒ¼: ${error.message}`;
        console.error(error);
      }
    }

    // ãƒ¬ãƒ¼ã‚¹HTMLã‚’åˆ†å‰²
    function splitRacesHTML(html) {
      const races = [];

      // ãƒ‘ã‚¿ãƒ¼ãƒ³1: <div class='racename'> ã¾ãŸã¯ <div class="racename"> ã§åˆ†å‰²
      const racenamePattern = /<div\s+class=["']racename["']\s*>/gi;

      // å„ãƒ¬ãƒ¼ã‚¹ã®é–‹å§‹ä½ç½®ã‚’è¦‹ã¤ã‘ã‚‹
      const matches = [];
      let match;
      racenamePattern.lastIndex = 0; // ãƒªã‚»ãƒƒãƒˆ
      while ((match = racenamePattern.exec(html)) !== null) {
        matches.push(match.index);
      }

      console.log(`[splitRacesHTML] racenameæ¤œå‡ºæ•°: ${matches.length}å€‹`);

      // å„ãƒ¬ãƒ¼ã‚¹ã®HTMLã‚’æŠ½å‡ºï¼ˆæ¬¡ã®racenameã¾ã§ã€ã¾ãŸã¯æœ€å¾Œã¾ã§ï¼‰
      for (let i = 0; i < matches.length; i++) {
        const startIndex = matches[i];
        const endIndex = i < matches.length - 1 ? matches[i + 1] : html.length;
        const raceHTML = html.substring(startIndex, endIndex);

        // æœ€ä½é™ã®ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆtableãŒå«ã¾ã‚Œã¦ã„ã‚‹ã‹ï¼‰
        if (raceHTML.includes('<table')) {
          races.push(raceHTML);
          console.log(`[splitRacesHTML] ãƒ¬ãƒ¼ã‚¹${i + 1}: ${raceHTML.length}æ–‡å­—`);
        } else {
          console.warn(`[splitRacesHTML] ãƒ¬ãƒ¼ã‚¹${i + 1}: tableãŒè¦‹ã¤ã‹ã‚‰ãªã„`);
        }
      }

      console.log(`[splitRacesHTML] æœ€çµ‚çš„ã«æ¤œå‡ºã—ãŸãƒ¬ãƒ¼ã‚¹æ•°: ${races.length}`);
      return races;
    }

    // ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼è¡¨ç¤º
    function displayBatchPreview(results, date, venue) {
      const previewSection = document.getElementById('previewSection');
      const raceSummary = document.getElementById('raceSummary');
      const raceDetails = document.getElementById('raceDetails');

      const successResults = results.filter(r => r.success);
      const errorResults = results.filter(r => !r.success);

      // ã‚µãƒãƒªãƒ¼è¡¨ç¤º
      raceSummary.innerHTML = `
        <h3 style="margin-bottom: var(--spacing-md);">ğŸ“Š è§£æã‚µãƒãƒªãƒ¼</h3>
        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: var(--spacing-md);">
          <div style="padding: var(--spacing-md); background: rgba(16, 185, 129, 0.1); border-radius: var(--radius-md);">
            <div style="font-size: 2rem; font-weight: 700; color: var(--success);">${successResults.length}</div>
            <div style="color: var(--text-secondary);">æˆåŠŸ</div>
          </div>
          <div style="padding: var(--spacing-md); background: rgba(239, 68, 68, 0.1); border-radius: var(--radius-md);">
            <div style="font-size: 2rem; font-weight: 700; color: var(--error);">${errorResults.length}</div>
            <div style="color: var(--text-secondary);">ã‚¨ãƒ©ãƒ¼</div>
          </div>
          <div style="padding: var(--spacing-md); background: rgba(59, 130, 246, 0.1); border-radius: var(--radius-md);">
            <div style="font-size: 2rem; font-weight: 700; color: var(--primary-end);">${results.length}</div>
            <div style="color: var(--text-secondary);">åˆè¨ˆ</div>
          </div>
        </div>
      `;

      // å„ãƒ¬ãƒ¼ã‚¹ã®è©³ç´°
      let detailsHTML = '';
      results.forEach(result => {
        const statusClass = result.success ? 'success' : 'error';
        const statusText = result.success ? 'âœ… æˆåŠŸ' : 'âŒ ã‚¨ãƒ©ãƒ¼';

        detailsHTML += `
          <details class="race-detail-card ${statusClass}">
            <summary class="race-detail-header">
              <span class="race-number-badge">ç¬¬${result.raceNumber}R</span>
              <span class="race-status-badge ${statusClass}">${statusText}</span>
            </summary>
            <div class="race-detail-content">
              ${result.success ? generateRacePreviewHTML(result) : generateErrorHTML(result)}
            </div>
          </details>
        `;
      });

      raceDetails.innerHTML = detailsHTML;
      previewSection.style.display = 'block';
    }

    // ãƒ¬ãƒ¼ã‚¹ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼HTMLç”Ÿæˆï¼ˆè©³ç´°ç‰ˆï¼‰
    function generateRacePreviewHTML(result) {
      const { data } = result;

      let html = `
        <div style="margin-bottom: 1rem; padding: 1rem; background: var(--bg-tertiary); border-radius: 8px;">
          <h4 style="margin-bottom: 0.5rem;">ğŸ“‹ ãƒ¬ãƒ¼ã‚¹æƒ…å ±</h4>
          <p><strong>é–‹å‚¬:</strong> ${data.raceInfo.kaisaiInfo || '-'}</p>
          <p><strong>ç™ºèµ°:</strong> ${data.raceInfo.hassoTime || '-'}</p>
          <p><strong>ãƒ¬ãƒ¼ã‚¹å:</strong> ${data.raceInfo.raceName || '-'}</p>
          ${data.raceInfo.raceType ? `<p><strong>æ¡ä»¶:</strong> ${data.raceInfo.raceType}</p>` : ''}
          <p><strong>è·é›¢:</strong> ${data.raceInfo.surface}${data.raceInfo.distance}m</p>
          <p><strong>ã‚³ãƒ¼ã‚¹:</strong> ${data.raceInfo.courseInfo || '-'}</p>
          <p><strong>å‡ºèµ°é ­æ•°:</strong> ${data.horses.length}é ­</p>
        </div>
      `;

      // æŒ¯ã‚Šåˆ†ã‘çµæœï¼ˆã‚«ãƒ¼ãƒ‰å½¢å¼ãƒ»7ç¨®é¡å…¨è¡¨ç¤ºï¼‰
      html += '<div style="margin-bottom: 1.5rem;">';
      html += '<h4 style="margin-bottom: 0.75rem;">ğŸ¯ è‡ªå‹•æŒ¯ã‚Šåˆ†ã‘çµæœ</h4>';
      html += '<div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(250px, 1fr)); gap: 0.75rem;">';

      const formatHorse = (horse) => horse ? `${horse.number}ç•ª ${horse.name} (${horse.totalScore}ç‚¹)` : "ãªã—";

      const createCard = (bgColor, borderColor, title, horses) => {
        const horsesList = Array.isArray(horses)
          ? horses.map(h => `<li style="margin: 0.25rem 0;">${formatHorse(h)}</li>`).join("")
          : `<li style="margin: 0.25rem 0;">${formatHorse(horses)}</li>`;

        const isEmpty = (Array.isArray(horses) && horses.length === 0) || (!Array.isArray(horses) && !horses);
        const content = isEmpty ? "<li>ãªã—</li>" : horsesList;

        return `
          <div style="background: ${bgColor}; border-left: 4px solid ${borderColor}; border-radius: 4px; padding: 0.75rem;">
            <div style="font-weight: 600; margin-bottom: 0.5rem; color: ${borderColor};">${title}</div>
            <ul style="list-style: none; padding: 0; margin: 0; font-size: 0.875rem;">${content}</ul>
          </div>
        `;
      };

      html += createCard('rgba(239, 68, 68, 0.1)', '#ef4444', 'â— æœ¬å‘½', data.horses.find(h => h.number === data.assignments.main));
      html += createCard('rgba(59, 130, 246, 0.1)', '#3b82f6', 'â—‹ å¯¾æŠ—', data.horses.find(h => h.number === data.assignments.sub));
      html += createCard('rgba(245, 158, 11, 0.1)', '#f59e0b', 'â–² å˜ç©´', data.horses.find(h => h.number === data.assignments.hole));
      html += createCard('rgba(16, 185, 129, 0.1)', '#10b981', 'â–³ é€£ä¸‹æœ€ä¸Šä½', data.horses.find(h => h.number === data.assignments.connectTop));

      const connectHorses = data.assignments.connect.map(num => data.horses.find(h => h.number === num)).filter(h => h);
      html += createCard('rgba(139, 92, 246, 0.1)', '#8b5cf6', 'â–³ é€£ä¸‹ (1~3é ­)', connectHorses);

      const reserveHorses = data.assignments.reserve.map(num => data.horses.find(h => h.number === num)).filter(h => h);
      html += createCard('rgba(100, 116, 139, 0.1)', '#64748b', 'Ã— è£œæ¬  (1ç‚¹ä»¥ä¸Š)', reserveHorses);

      const noneHorses = data.assignments.none.map(num => data.horses.find(h => h.number === num)).filter(h => h);
      html += createCard('rgba(156, 163, 175, 0.1)', '#9ca3af', 'ç„¡ (0ç‚¹)', noneHorses);

      html += '</div>';
      html += '</div>';

      // å…¨é¦¬ã®è©³ç´°ãƒ†ãƒ¼ãƒ–ãƒ«ï¼ˆå°Nâ†’å°1ã®é †ã«è¡¨ç¤ºï¼‰
      html += '<div style="margin-bottom: 1rem;">';
      html += '<h4 style="margin-bottom: 0.5rem;">ğŸ‡ å…¨é¦¬è©³ç´°</h4>';
      html += '<div style="overflow-x: auto;">';
      html += '<table style="width: 100%; border-collapse: collapse; font-size: 0.875rem;">';
      html += '<thead><tr style="background: var(--bg-tertiary);">';
      html += '<th style="padding: 0.5rem; border: 1px solid var(--border-color);">é¦¬ç•ª</th>';

      // å°ã‚’é€†é †ï¼ˆå°Nâ†’å°1ï¼‰ã§è¡¨ç¤º
      data.predictors.forEach(p => {
        html += `<th style="padding: 0.5rem; border: 1px solid var(--border-color);">${p}</th>`;
      });

      html += '<th style="padding: 0.5rem; border: 1px solid var(--border-color);">é¦¬å</th>';
      html += '<th style="padding: 0.5rem; border: 1px solid var(--border-color);">æ€§é½¢</th>';
      html += '<th style="padding: 0.5rem; border: 1px solid var(--border-color);">é¨æ‰‹</th>';
      html += '<th style="padding: 0.5rem; border: 1px solid var(--border-color);">å©èˆ</th>';
      html += '<th style="padding: 0.5rem; border: 1px solid var(--border-color);">åˆè¨ˆç‚¹</th>';
      html += '<th style="padding: 0.5rem; border: 1px solid var(--border-color);">æŒ¯ã‚Šåˆ†ã‘</th>';
      html += '</tr></thead><tbody>';

      // ç‚¹æ•°é †ã«ã‚½ãƒ¼ãƒˆ
      const sortedHorses = [...data.horses].sort((a, b) => b.totalScore - a.totalScore);

      sortedHorses.forEach(horse => {
        html += '<tr>';
        html += `<td style="padding: 0.5rem; border: 1px solid var(--border-color); text-align: center;">${horse.number}</td>`;

        // å°ã‚’é€†é †ã§è¡¨ç¤º
        data.predictors.forEach(p => {
          const mark = horse.marks[p] || '-';
          html += `<td style="padding: 0.5rem; border: 1px solid var(--border-color); text-align: center;">${mark}</td>`;
        });

        html += `<td style="padding: 0.5rem; border: 1px solid var(--border-color);">${horse.name}</td>`;
        html += `<td style="padding: 0.5rem; border: 1px solid var(--border-color); text-align: center;">${horse.seirei || '-'}</td>`;
        html += `<td style="padding: 0.5rem; border: 1px solid var(--border-color); text-align: center;">${horse.kisyu || '-'}</td>`;
        html += `<td style="padding: 0.5rem; border: 1px solid var(--border-color); text-align: center;">${horse.kyusya || '-'}</td>`;
        html += `<td style="padding: 0.5rem; border: 1px solid var(--border-color); text-align: center; font-weight: 600;">${horse.totalScore}</td>`;
        html += `<td style="padding: 0.5rem; border: 1px solid var(--border-color); text-align: center;">${horse.assignment}</td>`;
        html += '</tr>';
      });

      html += '</tbody></table>';
      html += '</div>';
      html += '</div>';

      return html;
    }

    // ã‚¨ãƒ©ãƒ¼HTMLç”Ÿæˆ
    function generateErrorHTML(result) {
      return `
        <div style="color: var(--error);">
          <h4>âŒ ã‚¨ãƒ©ãƒ¼å†…å®¹</h4>
          <ul style="margin-left: var(--spacing-lg);">
            ${result.errors.map(err => `<li>${err}</li>`).join('')}
          </ul>
        </div>
      `;
    }

    // JSONå…¨ã‚³ãƒ”ãƒ¼
    function copyAllJSON() {
      const successResults = batchResults.filter(r => r.success);
      if (successResults.length === 0) {
        alert('ã‚³ãƒ”ãƒ¼ã§ãã‚‹ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“');
        return;
      }

      const date = successResults[0].date;
      const venue = successResults[0].venue;

      const jsonData = {
        raceDate: date,
        lastUpdated: new Date().toISOString(),
        track: venue,
        totalRaces: successResults.length,
        races: successResults.map(r => r.data),
      };

      navigator.clipboard.writeText(JSON.stringify(jsonData, null, 2)).then(() => {
        alert('JSONã‚’ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸï¼');
      });
    }

    // ä¸€æ‹¬ä¿å­˜
    async function saveAllRacesToGit(forceOverwrite = false) {
      const successResults = batchResults.filter(r => r.success);
      if (successResults.length === 0) {
        alert('ä¿å­˜ã§ãã‚‹ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“');
        return;
      }

      const btn = document.getElementById('saveAllBtn');
      const statusDiv = document.getElementById('saveStatus');

      btn.disabled = true;
      btn.textContent = 'â³ ä¿å­˜ä¸­...';

      statusDiv.style.display = 'block';
      statusDiv.className = 'save-status loading';
      statusDiv.textContent = forceOverwrite
        ? `ğŸ”¥ ${successResults.length}ãƒ¬ãƒ¼ã‚¹åˆ†ã‚’å®Œå…¨ä¸Šæ›¸ãä¸­...`
        : `ğŸš€ ${successResults.length}ãƒ¬ãƒ¼ã‚¹åˆ†ã‚’ä¿å­˜ä¸­...`;

      try {
        const date = successResults[0].date;
        const venue = successResults[0].venue;

        const jsonData = {
          raceDate: date,
          lastUpdated: new Date().toISOString(),
          track: venue,
          totalRaces: successResults.length,
          races: successResults.map(r => r.data),
        };

        const response = await fetch('/.netlify/functions/save-predictions-jra', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            raceDate: date,
            track: venue,
            data: jsonData,
            forceOverwrite: forceOverwrite
          })
        });

        const result = await response.json();

        if (response.ok && result.success) {
          statusDiv.className = 'save-status success';
          statusDiv.innerHTML = `
            âœ… ${successResults.length}ãƒ¬ãƒ¼ã‚¹åˆ†ã®ä¿å­˜æˆåŠŸï¼<br>
            <strong>ãƒ•ã‚¡ã‚¤ãƒ«:</strong> ${result.path}<br>
            <strong>ã‚³ãƒŸãƒƒãƒˆ:</strong> ${result.sha?.substring(0, 7) || '-'}
          `;
          btn.textContent = 'âœ… ä¿å­˜å®Œäº†';
        } else {
          statusDiv.className = 'save-status error';
          statusDiv.innerHTML = `âŒ ã‚¨ãƒ©ãƒ¼: ${result.error || 'ä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸ'}`;
          btn.disabled = false;
          btn.textContent = 'ğŸš€ 12ãƒ¬ãƒ¼ã‚¹ä¸€æ‹¬ä¿å­˜ã—ã¦Git Push';
        }
      } catch (error) {
        statusDiv.className = 'save-status error';
        statusDiv.innerHTML = `âŒ ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚¨ãƒ©ãƒ¼: ${error.message}`;
        btn.disabled = false;
        btn.textContent = 'ğŸš€ 12ãƒ¬ãƒ¼ã‚¹ä¸€æ‹¬ä¿å­˜ã—ã¦Git Push';
      }
    }

    // ===== æŠ½å‡ºãƒ­ã‚¸ãƒƒã‚¯ï¼ˆJRAç‰ˆãƒ»predictions-manager-jraã‹ã‚‰å†åˆ©ç”¨ï¼‰ =====

    function extractPredictions(html) {
      const errors = [];
      try {
        const parser = new DOMParser();
        const doc = parser.parseFromString(html, 'text/html');

        const table = doc.querySelector('table.default.syutuba');
        if (!table) {
          errors.push('å‡ºé¦¬è¡¨ãƒ†ãƒ¼ãƒ–ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
          return { success: false, horses: [], predictors: [], errors };
        }

        const headerRow = table.querySelector('thead tr');
        if (!headerRow) {
          errors.push('ãƒ˜ãƒƒãƒ€ãƒ¼è¡ŒãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
          return { success: false, horses: [], predictors: [], errors };
        }

        const detectedPredictors = detectPredictors(headerRow);
        const predictors = detectedPredictors.map((_, index) => `å°${detectedPredictors.length - index}`);

        const rows = table.querySelectorAll('tbody tr');
        const horses = [];

        rows.forEach(row => {
          const horse = extractHorseFromRow(row, detectedPredictors, predictors);
          if (horse) {
            horses.push(horse);
          }
        });

        return {
          success: true,
          horses,
          predictors,
          errors,
        };
      } catch (error) {
        errors.push(`æŠ½å‡ºã‚¨ãƒ©ãƒ¼: ${error.message}`);
        return { success: false, horses: [], predictors: [], errors };
      }
    }

    function detectPredictors(headerRow) {
      const headers = [];
      const ths = headerRow.querySelectorAll('th');

      const excludeList = [
        'æ ç•ª', 'æ ', 'é¦¬ç•ª', 'é¦¬å', 'é¸æŠ', 'æ€§é½¢', 'æ¸›é‡', 'é¨æ‰‹', 'æ–¤é‡', 'é‡é‡',
        'å©èˆ', 'çŸ­è©•', 'å¢—æ¸›', 'å˜å‹', 'äººæ°—', 'ç€é †', 'é¦¬ä½“é‡', 'ãƒ–ãƒªãƒ³ã‚«',
        'ã‚ªãƒƒã‚º', 'ã‚¿ã‚¤ãƒ ', 'ç€å·®', 'ãƒšãƒ¼ã‚¹', 'ä¸Š3F', 'èª¿æ•™å¸«', 'é¦¬ä¸»', 'ãƒ¬ã‚¤ãƒ†ã‚£ãƒ³ã‚°', 'èª¿æ•™å‹•ç”»'
      ];

      ths.forEach((th) => {
        const text = th.textContent?.trim() || '';

        if (excludeList.some(keyword => text.includes(keyword))) {
          return;
        }

        if (text.includes('My') || text.includes('M') && text.includes('y')) {
          return;
        }

        if (
          text === 'CPU' ||
          text === 'æœ¬ç´™' ||
          (text.length >= 2 && text.length <= 4 && /^[ã-ã‚“ã‚¡-ãƒ¶ãƒ¼ä¸€-é¾ ]+$/.test(text))
        ) {
          headers.push(text);
        }
      });

      return headers;
    }

    function extractMarkFromElement(element) {
      const text = element.textContent?.trim() || '';

      if (element.querySelector('svg')) {
        return 'svg';
      }

      const markMap = {
        'â—': 'â—',
        'â—‹': 'â—‹',
        'â–²': 'â–²',
        'â–³': 'â–³',
        'Ã—': 'Ã—',
        'ç©´': 'ç©´',
        'æ³¨': 'æ³¨',
        'æ¶ˆ': 'æ¶ˆ',
        '-': '-',
        '': '-',
      };

      return markMap[text] || text;
    }

    function extractHorseFromRow(row, detectedPredictors, anonymizedPredictors) {
      const tds = Array.from(row.querySelectorAll('td'));

      let number = 0;
      let name = '';
      let umacd = undefined;
      const marks = {};
      let seirei = '';
      let kisyu = '';
      let kinryo = '';
      let kyusya = '';

      const umabanTd = tds.find(td => td.classList.contains('umaban'));
      if (umabanTd) {
        number = parseInt(umabanTd.textContent?.trim() || '0', 10);
      } else if (tds.length >= 2) {
        const secondCol = tds[1].textContent?.trim() || '';
        const parsed = parseInt(secondCol, 10);
        if (!isNaN(parsed)) {
          number = parsed;
        }
      }

      const bameiTd = tds.find(td => td.classList.contains('bamei'));
      if (bameiTd) {
        const link = bameiTd.querySelector('a');
        if (link) {
          name = link.textContent?.trim() || '';
          const href = link.getAttribute('href') || '';
          const match = href.match(/\/uma\/(\d+)/);
          if (match) {
            umacd = match[1];
          }
        }
      }

      const headerRow = row.closest('table')?.querySelector('thead tr');
      if (headerRow) {
        const ths = Array.from(headerRow.querySelectorAll('th'));
        const markIndices = [];

        ths.forEach((th, idx) => {
          const text = th.textContent?.trim() || '';
          detectedPredictors.forEach(predictor => {
            if (text === predictor || text.includes(predictor)) {
              markIndices.push(idx);
            }
          });
        });

        markIndices.forEach((thIdx, predictorIdx) => {
          if (thIdx < tds.length && predictorIdx < anonymizedPredictors.length) {
            const td = tds[thIdx];
            const mark = extractMarkFromElement(td);
            marks[anonymizedPredictors[predictorIdx]] = mark;
          }
        });

        const fieldMap = {
          'æ€§é½¢': 'seirei',
          'é¨æ‰‹': 'kisyu',
          'æ–¤é‡': 'kinryo',
          'é‡é‡': 'kinryo',
          'å©èˆ': 'kyusya',
          'èª¿æ•™å¸«': 'kyusya',
        };

        ths.forEach((th, idx) => {
          const text = th.textContent?.trim() || '';
          const textNoSpace = text.replace(/\s+/g, '');
          Object.entries(fieldMap).forEach(([keyword, fieldName]) => {
            if (textNoSpace.includes(keyword)) {
              if (idx < tds.length) {
                const td = tds[idx];

                if (fieldName === 'kyusya') {
                  const syozokuSpan = td.querySelector('.syozoku');
                  if (syozokuSpan) {
                    const syozoku = syozokuSpan.textContent?.trim() || '';
                    const trainerName = td.textContent?.trim().replace(syozoku, '') || '';
                    kyusya = `(${syozoku})${trainerName}`;
                  } else {
                    kyusya = td.textContent?.trim() || '';
                  }
                } else {
                  const value = td.textContent?.trim() || '';
                  if (fieldName === 'seirei') seirei = value;
                  else if (fieldName === 'kisyu') kisyu = value;
                  else if (fieldName === 'kinryo') kinryo = value;
                }
              }
            }
          });
        });
      }

      if (number === 0 || !name) {
        return null;
      }

      return {
        number,
        name,
        umacd,
        marks,
        seirei,
        kisyu,
        kinryo,
        kyusya,
      };
    }

    function extractRaceInfo(html) {
      const parser = new DOMParser();
      const doc = parser.parseFromString(html, 'text/html');

      const racenameDiv = doc.querySelector('div.racename');
      let date = '';
      let raceName = '';
      let raceType = '';
      let distance = '';
      let surface = '';
      let raceNo = '';
      let hassoTime = '';
      let kaisaiInfo = '';
      let tenkiBaba = '';
      let recordTime = '';
      let estimatedTime = '';
      let prizes = [];
      let courseInfo = '';
      let venue = '';

      if (racenameDiv) {
        const text = racenameDiv.textContent || '';

        const dateMatch = text.match(/(\d{4})å¹´(\d{1,2})æœˆ(\d{1,2})æ—¥/);
        if (dateMatch) {
          date = `${dateMatch[1]}å¹´${dateMatch[2]}æœˆ${dateMatch[3]}æ—¥`;
        }

        const h2 = racenameDiv.querySelector('h2');
        if (h2) {
          kaisaiInfo = h2.textContent?.trim() || '';
        }

        const racenoP = racenameDiv.querySelector('p.raceno');
        if (racenoP) {
          raceNo = racenoP.textContent?.trim() || '';
        }

        const hassotimeP = racenameDiv.querySelector('p.hassotime');
        if (hassotimeP) {
          hassoTime = hassotimeP.textContent?.trim() || '';
        }

        const h1 = racenameDiv.querySelector('h1');
        if (h1) {
          raceName = h1.textContent?.trim() || '';
        }

        const h1block = racenameDiv.querySelector('div.h1block');
        if (h1block) {
          const pTags = h1block.querySelectorAll('p');
          if (pTags.length > 0) {
            raceType = pTags[0].textContent?.trim() || '';
          }
        }

        const racekyoriP = racenameDiv.querySelector('p.racekyori');
        if (racekyoriP) {
          const button = racekyoriP.querySelector('button');
          if (button) {
            const buttonText = button.textContent?.trim() || '';
            const distanceMatch = buttonText.match(/(\d{3,4})m?/);
            if (distanceMatch) {
              distance = distanceMatch[1];
            }
          }
        }

        const raceshibadaP = racenameDiv.querySelector('p.raceshibada');
        if (raceshibadaP) {
          const shibadaText = raceshibadaP.textContent?.trim() || '';
          courseInfo = shibadaText;
          if (shibadaText.includes('èŠ')) {
            surface = 'èŠ';
          } else if (shibadaText.includes('ãƒ€ãƒ¼ãƒˆ')) {
            surface = 'ãƒ€ãƒ¼ãƒˆ';
          }
        }

        const tenkibabaP = racenameDiv.querySelector('p.tenkibaba');
        if (tenkibabaP) {
          tenkiBaba = tenkibabaP.textContent?.trim() || '';
        }

        const racenametimeDiv = racenameDiv.querySelector('div.racenametime');
        if (racenametimeDiv) {
          const pTags = racenametimeDiv.querySelectorAll('p');
          pTags.forEach(p => {
            const pText = p.textContent?.trim() || '';
            if (pText.startsWith('ãƒ¬ã‚³ãƒ¼ãƒ‰')) {
              recordTime = pText;
            } else if (pText.startsWith('è‰¯') || pText.startsWith('é‡') || pText.startsWith('ç¨') || pText.startsWith('ä¸')) {
              estimatedTime += (estimatedTime ? ' / ' : '') + pText;
            }
          });
        }

        const racesyoukinDiv = racenameDiv.querySelector('div.racesyoukin');
        if (racesyoukinDiv) {
          const liTags = racesyoukinDiv.querySelectorAll('li');
          liTags.forEach((li, index) => {
            const span = li.querySelector('span');
            if (span) {
              prizes.push(`${index + 1}ç€: ${span.textContent?.trim() || ''}`);
            }
          });
        }

        // ç«¶é¦¬å ´è‡ªå‹•æŠ½å‡ºï¼ˆkaisaiInfoã‹ã‚‰ï¼‰
        // ä¾‹: "1å›å°å€‰6æ—¥ç›®" â†’ "å°å€‰"
        const venueList = ['æ±äº¬', 'ä¸­å±±', 'äº¬éƒ½', 'é˜ªç¥', 'ä¸­äº¬', 'æ–°æ½Ÿ', 'ç¦å³¶', 'å°å€‰', 'æœ­å¹Œ', 'å‡½é¤¨'];
        for (const v of venueList) {
          if (kaisaiInfo.includes(v)) {
            venue = v;
            break;
          }
        }
      }

      return {
        date, kaisaiInfo, venue, raceNo, hassoTime, raceName, raceType,
        distance, surface, courseInfo, tenkiBaba, recordTime, estimatedTime, prizes
      };
    }

    function scoreAndAssign(result) {
      const markScores = {
        'â—': 5,
        'â—‹': 4,
        'â–²': 3,
        'svg': 2,
        'ç©´': 2,
        'â–³': 1,
        '-': 0,
      };

      const horses = result.horses.map(horse => {
        let totalScore = 0;
        Object.values(horse.marks).forEach(mark => {
          totalScore += markScores[mark] || 0;
        });

        return {
          ...horse,
          totalScore,
        };
      });

      horses.sort((a, b) => b.totalScore - a.totalScore);

      const assignments = {
        main: null,
        sub: null,
        hole: null,
        connectTop: null,
        connect: [],
        reserve: [],
        none: [],
      };

      horses.forEach((horse, index) => {
        if (index === 0) {
          assignments.main = horse;
          horse.assignment = 'æœ¬å‘½';
        } else if (index === 1) {
          assignments.sub = horse;
          horse.assignment = 'å¯¾æŠ—';
        } else if (index === 2) {
          assignments.hole = horse;
          horse.assignment = 'å˜ç©´';
        } else if (index === 3) {
          assignments.connectTop = horse;
          horse.assignment = 'é€£ä¸‹æœ€ä¸Šä½';
        } else if (index >= 4 && index <= 6 && horse.totalScore > 0) {
          assignments.connect.push(horse);
          horse.assignment = 'é€£ä¸‹';
        } else if (horse.totalScore > 0) {
          assignments.reserve.push(horse);
          horse.assignment = 'è£œæ¬ ';
        } else {
          assignments.none.push(horse);
          horse.assignment = 'ç„¡';
        }
      });

      return {
        ...result,
        horses,
        assignments,
      };
    }
  </script>
</BaseLayout>
